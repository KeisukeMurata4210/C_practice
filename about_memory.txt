・メモリは1列のロッカー　2GBなら21億個以上のロッカーが一列に並んでいるイメージ
　その一つ一つに2進数で状態を記録する（0か1）
  ロッカー1つを1ビット

・8個を一単位として考える
　00000000　〜 11111111、10進数でいうと 0 〜 255
　この8桁＝8ビットが1バイト。
  CPUが32ビット　＝　CPUが1回で扱うメモリの桁数が32ビット　＝ 8ビットのかたまり（1バイト）が4つ

・1バイト（8ビット）ごとに番号がつけられている
　この番号の代わりに分かりやすい名前をつけたのが「変数名」

・変数につけられた番号を「アドレス」

・続けて定義したint型変数のアドレスを調べると、4番ずつずれる
　⇦int型のサイズが4バイトだから
   char型は1バイト

・メモリーがわかると配列の仕組みがわかる
　要素のアドレス　　：順番に並ぶ（int型なら4バイトずつ）
　配列自体のアドレス：要素の1番目と同じアドレス
　→最初の要素のアドレスさえわかれば、そこから辿っていけば求める要素にたどり着ける仕組み

・「&」はアドレスを求める演算子
　配列にscanfで値を代入させるときに「&」がいらないのは、配列名はアドレスを表しているため演算する必要がないから

・C言語では値渡ししかできないため&演算子を使う。&を使った渡し方を慣習的に参照渡しと呼ぶことがある
　cf）scanf関数も値（変数の値のコピー）しかやり取りできないから、入力値を書き込むことができない。
　    そこで「&」を使う

・一般には「ポインタ」＝アドレスを記憶する変数の型で参照渡しの時の受け取る側の関数で使うもの
　だが正確には違う。

・「ポインタ」には3つの意味がある
  ①ポインタ型　：int型、double型と同じ意味区分
  ②ポインタ値　：整数、実数と同じ意味区分
  ③ポインタ変数：int型変数、double型変数と同じ意味区分

・①ポインタ型：他の型とポインタ型を合体させて初めて存在できる
　            int型へのポインタ型、double型へのポインタ型、int型へのポインタへのポインタ型
  b/c 型のバイト分をまとめて取り出す必要があるため、どの型を取り出すか分かっている必要がある（int型＝4バイト）

・②ポインタ値：名前通りの意味。実際はint型の整数に過ぎないが、目的が違うため別の型として扱っている

・③ポインタ変数：元となった型の変数のアドレスを代入できる、読み出し書き換えできる。
　 通常変数モードでも使え、その時は普通の変数としての演算ができる

・ポインタ変数は宣言時点ではデタラメで使えない値が代入されている。
  謝って使い暴走させないために「NULL」を代入することでアドレスが入っていないことを示す

・ポインタ変数の通常変数モード（*pなど）では、保持しているアドレスの値を取得する。

・「*」の3つの意味
  ①乗算演算子　　　2乗3乗
  ②間接参照演算子　ポインタ変数の通常変数モード
  ③ポインタ変数の宣言時　　間接参照演算子とは「全く別の記号」

・ポインタの変数の全貌は、
  ポインタ変数モードの時にメモリのアドレスを代入し、
  通常変数モードでそのアドレスのメモリの値を操作する

データや値の実体ではなくアドレスだけを保持してそこに飛ぶという意味で
Windowsのショートカットと同じ

・配列の[]の意味
　配列名は配列の最初の要素のメモリを指すポインタ
　[番号]で番号分アドレスに足している（＝移動している）
　→配列名でなくともアドレスさえ入っていれば、[]を使ってアドレスのたし算ができる

・配列宣言時の[]と要素を指定する[]はまったく別物
　 要素数の指定　　　アドレスに足し算する演算子

・配列とポインタはまったくの別物
　配列　　：多数の変数を順番づけでまとめて扱う方法。配列は変数の先頭を表す固定された変数
　ポインタ：アドレスを介して変数のショートカットを作る方法。好きな変数のアドレスを代入して好きなメモリ領域を使える可変的な変数
　 配列が順番づけを実現する方法としてアドレスの足し算を使っていて、
　 たまたまポインタも同じ機能を持っていた、というだけ。

・ポインタ演算　ポインタ名[要素番号] を *(ポインタ変数 + 要素番号)と書く